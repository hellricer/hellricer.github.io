<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>~hellricer/</title>
        <description>— a terminal dweller</description>        
        <link>https://hellricer.github.io</link>
        <atom:link href="https://hellricer.github.io/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
                <title>ELinks with BeautifulSoup</title>
                <description>&lt;p&gt;For many terminal dwellers like me, browsing the web is one of the last few scenarios where we have to leave our cozy terminals into the harsh cold GUI world. Complexity of today&#39;s websites simply won&#39;t cut it without graphics, preferably with high screen resolution.&lt;/p&gt;
&lt;p&gt;That&#39;s not to say that it&#39;s not worth to experiment with terminal-based browsers, though! Most people probably know about &lt;code&gt;w3m&lt;/code&gt; for its ability to display actual images and &lt;code&gt;lynx&lt;/code&gt; as the oldest one. But in this post, I&#39;d like to talk about &lt;a href=&#34;http://elinks.cz/&#34;&gt;ELinks&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It&#39;s arguably most feature-packed (read “bloated”) and also most user-friendly of the three. It supports tabs, multiple downloads, bookmarks, it has rudimentary support for CSS and even JavaScript. And, after some tweaking, it can actually look pretty good!&lt;/p&gt;
&lt;figure&gt;
    &lt;a href=&#34;https://hellricer.github.io//assets/images/elinks-ddg.png&#34;&gt;&lt;img src=&#34;https://hellricer.github.io//assets/images/elinks-ddg.png&#34; a</description>
                <pubDate>Wed, 29 May 2019 00:00:00 </pubDate>
                <link>https://hellricer.github.io/2019/05/29/elinks-with-beautifulsoup.html</link>
                <guid isPermaLink="true">https://hellricer.github.io/2019/05/29/elinks-with-beautifulsoup.html</guid>
            </item>
        
            <item>
                <title>Ctrl+Arrows in terminal</title>
                <description>&lt;p&gt;Basically every program with some kind of input field supports &lt;code&gt;Ctrl+Arrows&lt;/code&gt; for skipping over words,
&lt;code&gt;Ctrl+Backspace&lt;/code&gt;, &lt;code&gt;Ctrl+Del&lt;/code&gt; for deleting words, &lt;code&gt;Ctrl+Shift+Delete&lt;/code&gt; for deleting rest of the line, etc.&lt;/p&gt;
&lt;p&gt;Terminal emulators, on the other hand…&lt;/p&gt;
&lt;p&gt;We could go to great lengths explaining reasons, history of vt100, etc… But the reality is that even when you&#39;re not particularly fond of GUI apps, you probably use at least a web browser and you likely have these shortcuts engraved into your muscle memory anyway.&lt;/p&gt;
&lt;p&gt;Of course, you can use &lt;code&gt;Alt+Arrow&lt;/code&gt; and other &lt;a href=&#34;https://readline.kablamo.org/emacs.html&#34;&gt;very powerful&lt;/a&gt; &lt;code&gt;readline&lt;/code&gt; bindings, but that means learning
whole new, &lt;a href=&#34;https://clementc.github.io/blog/2018/01/25/moving_cli/&#34;&gt;quite esoteric set of shortcuts for rather basic things&lt;/a&gt; like moving around and deleting text.&lt;/p&gt;
&lt;p&gt;So, if you want to join me in spitting on the VT100&#39;s grave </description>
                <pubDate>Tue, 21 May 2019 00:00:00 </pubDate>
                <link>https://hellricer.github.io/2019/05/21/ctrl-arrows-in-terminal.html</link>
                <guid isPermaLink="true">https://hellricer.github.io/2019/05/21/ctrl-arrows-in-terminal.html</guid>
            </item>
        
            <item>
                <title>New webpage</title>
                <description>&lt;p&gt;Hello!&lt;/p&gt;
&lt;p&gt;My name is Hellricer.&lt;/p&gt;
&lt;p&gt;This blog will serve as a place to talk about my experiences with terminals and terminal-based programs, great software I&#39;ve found, tricks &amp;amp; tips for making your time in terminal more enjoyable, “ricing” and GNU/Linux in general.&lt;/p&gt;
&lt;p&gt;Most posts will revolve around programs like &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;tmux&lt;/code&gt;, &lt;code&gt;bash&lt;/code&gt; and so on.&lt;/p&gt;
&lt;h1&gt;About this website&lt;/h1&gt;
&lt;p&gt;This website is based on Jekyll and uses modified version of &lt;a href=&#34;https://github.com/mmistakes/so-simple-theme&#34;&gt;so-simple-theme&lt;/a&gt;, but I&#39;m using &lt;a href=&#34;http://obraz.pirx.ru&#34;&gt;Obraz&lt;/a&gt; for generating it.&lt;/p&gt;
&lt;p&gt;It aims to be modern-looking and responsive, while still being tiny (~1MB) and usable even in terminal-based browsers like &lt;code&gt;w3m&lt;/code&gt;, &lt;code&gt;lynx&lt;/code&gt; or &lt;code&gt;elinks&lt;/code&gt; (pictured below).&lt;/p&gt;
&lt;figure&gt;
    &lt;a href=&#34;https://hellricer.github.io//assets/images/editing-webpage.png&#34;&gt;&lt;img src=&#34;https://hellricer.github.io//assets/images/editin</description>
                <pubDate>Mon, 20 May 2019 00:00:00 </pubDate>
                <link>https://hellricer.github.io/2019/05/20/new-webpage.html</link>
                <guid isPermaLink="true">https://hellricer.github.io/2019/05/20/new-webpage.html</guid>
            </item>
        
            <item>
                <title>Genes in Middle-Earth</title>
                <description>&lt;p&gt;&lt;em&gt;...one script to find them all,
and into GEDCOM bind them...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I love Middle-Earth.  Out of all the imaginary places invented for the entertainment, &lt;em&gt;Arda&lt;/em&gt; is arguably
the most complex one.  The amount of information that accompanies the stories is overwhelming.  Tolkien is known
to be genius linguist - languages of his world evolve in time, fork into dialects and influence each other.
But his sense for geography and history is just as incredible.  There are more than 70 kingdoms with several hundreds of
people documented at least to some extent.  Some can be find in family trees printed in appendices of the books, some
family relations are only mentioned in stories, but there&#39;s lot of them.  So, how about we map them?&lt;/p&gt;
&lt;p&gt;I&#39;m obviously not the first one to think of digitalizing Tolkien&#39;s genealogies.  &lt;a href=&#34;http://www.minastirith.com/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=1;t=000070&#34;&gt;There are&lt;/a&gt;
some ancient forum threads that dealt with digitalizing th</description>
                <pubDate>Thu, 30 Apr 2015 00:00:00 </pubDate>
                <link>https://hellricer.github.io/2015/04/30/genes-in-middle-earth.html</link>
                <guid isPermaLink="true">https://hellricer.github.io/2015/04/30/genes-in-middle-earth.html</guid>
            </item>
        
            <item>
                <title>Color me impressed</title>
                <description>&lt;p&gt;I&#39;m crazy about colors.&lt;/p&gt;
&lt;p&gt;I work with terminal emulators all the time and nothings is more deterrent to
me than big wall of black &amp;amp; white text spitted out into my 300x100 terminal.&lt;/p&gt;
&lt;p&gt;I want my errors red and successes green, I want numbers, URLs and paths pop
out from the rest of the text, I want colored logs, compiler outputs, source
code snippets... It really makes your terminal experience much more fun.&lt;/p&gt;
&lt;p&gt;So let&#39;s take a look where my obsession brought me so far.&lt;/p&gt;
&lt;h2&gt;Brief history&lt;/h2&gt;
&lt;p&gt;In the late 70s, the number of character-oriented terminals was rapidly
expanding. Of course there was no &#34;de jure&#34; standard and each manufacturer
handled their &lt;a href=&#34;http://en.wikipedia.org/wiki/Escape_sequence&#34;&gt;escape sequences&lt;/a&gt;
differently. That meant that every screen-handling program had to be written
for one (type of) terminal only.&lt;/p&gt;
&lt;p&gt;To deal with these incompatibilities, Bill Joy foresightedly created the
&lt;code&gt;termcap&lt;/code&gt; library (&lt;strong&gt;term&lt;/strong</description>
                <pubDate>Wed, 08 Oct 2014 00:00:00 </pubDate>
                <link>https://hellricer.github.io/2014/10/08/color-me-impressed.html</link>
                <guid isPermaLink="true">https://hellricer.github.io/2014/10/08/color-me-impressed.html</guid>
            </item>
        
            <item>
                <title>Generating zsh completion functions</title>
                <description>&lt;p&gt;When I switched from &lt;code&gt;bash&lt;/code&gt; to &lt;code&gt;zsh&lt;/code&gt;, I was surprised to find how many
standard programs lacked completion functions. Only few of the coreutils are
supported in &lt;code&gt;zsh&lt;/code&gt; after the install.&lt;/p&gt;
&lt;p&gt;Although there are user-contributed repositories like &lt;a href=&#34;http://github.com/zsh-users/zsh-completions&#34;&gt;zsh-users/zsh-
completions&lt;/a&gt; I still couldn&#39;t
find completion functions for tools like &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;nl&lt;/code&gt;, &lt;code&gt;df&lt;/code&gt; and others.&lt;/p&gt;
&lt;p&gt;So I &lt;a href=&#34;http://github.com/zsh-users/zsh-completions/pull/250&#34;&gt;wrote some&lt;/a&gt; and
I&#39;ve realized that I basically just copied the info from help text to the
completion function. Boring! Something that even a machine could do. Well,
almost...&lt;/p&gt;
&lt;p&gt;Almost every program with command line arguments implements the &lt;code&gt;--help&lt;/code&gt;
option, which prints out all the options with their description. So why not
use that for generating the functions?&lt;/p&gt;
&lt;p&gt;... Because every program uses slightly diffe</description>
                <pubDate>Tue, 05 Aug 2014 00:00:00 </pubDate>
                <link>https://hellricer.github.io/2014/08/05/generating-completing-functions.html</link>
                <guid isPermaLink="true">https://hellricer.github.io/2014/08/05/generating-completing-functions.html</guid>
            </item>
        
    </channel>
</rss>